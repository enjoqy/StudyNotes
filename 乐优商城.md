# 1.乐优商城介绍

## 1.1.项目介绍

- 乐优商城是一个全品类的电商购物网站（B2C）
- 用户可以在线购买商品、加入购物车、下单、秒杀商品
- 管理员可以在后台管理商品的上下架、促销活动
- 管理员可以监控商品销售状况
- 客服可以在后台处理退款操作
- 希望未来3到5年可以支持千万用户的使用

## 1.2.系统架构

### 1.2.1.架构图

![lysc.png](assets/lysc.png)



- 我们整个项目采用的是前后端分离开发模式。
  - 前端分为两部分：

    - 后台管理：主要面向的是数据管理人员，采用基于Vue的单页应用开发方式
      - 商品管理，包括商品分类、品牌、商品规格等信息的管理
      - 销售管理，包括订单统计、订单退款处理、促销活动生成等
      - 用户管理，包括用户控制、冻结、解锁等
      - 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制
      - 统计，各种数据的统计分析展示
      - 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用
    - 门户系统：面向的是客户，门户采用的是Vue结合Nuxt实现服务端渲染方式
      - 搜索商品
      - 加入购物车
      - 下单
      - 评价商品等等

  - 后端

    后端采用基于SpringCloud的微服务架构，统一对外提供Rest风格接口，无论是后台管理还是门户系统都共享这些微服务接口，而微服务中通过JWT方式来识别用户身份，开放不同接口。

    到这里先不说了。如果继续追问微服务拆分粒度或者SpringCloud细节，再接着回答我们的服务拆分。

    

    无论是前台还是后台系统，都共享相同的微服务集群，包括：

    - 商品微服务：商品及商品分类、品牌、库存等的服务
    - 搜索微服务：实现搜索功能
    - 订单微服务：实现订单相关
    - 购物车微服务：实现购物车相关功能
    - 用户中心：用户的登录注册等功能
    - 认证中心：用户权限及服务权限认证
    - Eureka注册中心
    - Zuul网关服务
    - Spring Cloud Config配置中心
    - ...

    ## 1.3.技术选型

    ### 1.3.1.相关技术

    前端技术：

    - 基础的HTML、CSS、JavaScript（基于ES6标准）
    - Vue.js 2.0以及基于Vue的UI框架：Vuetify
    - 前端构建工具：WebPack
    - 前端安装包工具：NPM
    - Vue脚手架：Vue-cli
    - Vue路由：vue-router
    - ajax框架：axios
    - 基于Vue的富文本框架：quill-editor

    后端技术：

    - 基础的SpringMVC、Spring 5.0和MyBatis3
    - Spring Boot 2.0.1版本
    - Spring Cloud 最新版 Finchley.RC1
    - Redis-4.0
    - RabbitMQ-3.4
    - Elasticsearch-5.6.8
    - nginx-1.10.2
    - FastDFS - 5.0.8
    - MyCat
    - Thymeleaf
    - JWT

## 2.项目流程

### 2.1无状态登录

- 不登录可以实现加入购物车
- 传统ssm在服务器端保存session
- 1.无状态登陆
  	无状态不需要session，把登陆状态保存在cookie中
- 数据存储在localstore中，减轻服务端压力，永久保存在客户端

### 2.2 有状态登录

- 使用JWT鉴权，防伪造使用非对称加密RSA
- 服务器不保存sessionID，服务器签发token客户端

### 2.3 注册

- 使用的阿里的sms
- 抽取为单独的微服务
- 使用消息队列rebbitMQ进行通信
- rabbitMQ典型的：生产者、消费者模型。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。
- Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。
- Hibernate Validator
  - Hibernate Validator是Hibernate提供的一个开源框架，使用注解方式非常方便的实现服务端的数据校验

## 2.4 搜索

- 采用elasticsearch全文搜索引擎
- 组件Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具
- Lucene的IK分词器早在2012年已经没有维护了，现在我们要使用的是在其基础上维护升级的版本，并且开发为ElasticSearch的集成插件了，与Elasticsearch一起维护升级
- 对外提供resultful风格接口，即http请求
- Spring Data Elasticsearch是Spring Data项目下的一个子模块。
- Spring Data Redis是Spring Data项目下的一个子模块。

## 2.5 详情页

- 使用thymeleaf 静态化详情页
- 首先我们能想到的就是缓存技术，比如之前学习过的Redis。不过Redis适合数据规模比较小的情况

## 2.6 文件服务器

- 使用阿里巴巴的FastDFS
- 跟踪器（tracker）和存储[节点](https://baike.baidu.com/item/节点)（storage）。
  - 跟踪器主要做调度工作，在访问上起负载均衡的作用。
  - 存储节点存储文件，完成文件管理的所有功能：就是这样的存储、同步和提供存取接口

## 2.7 SPU和SKU

SPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集

SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品

# 2.技术总结

## 2.1 什么是springClou

- 微服务架构的解决方案，是很多组件的集合

- eureka：注册中心，服务的注册与发现
- zull：网关协议，路由请求，过滤器（ribbon hystrix）
- ribbon：负载均衡组件
- hystrix：熔断组件
- feign：远程调用组件(ribbon hystrix)

## 2.2 dubbo和springCloud区别

- rpc协议：自定义数据格式，限定技术，传输速度快，效率高 tcp，dubbo
- http协议：统一的数据格式，不限定技术 rest接口  tcp协议 springCloud

## 2.3 架构的演变

传统架构-->水平拆分-->垂直拆分（最早的分布式）-->soa(dubbo)-->微服务(springCloud)

## 2.4 微服务的特点

- 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责
- 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。
- 面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。
- 自治：自治是说服务间互相独立，互不干扰
  - 团队独立：每个服务都是一个独立的开发团队，人数不能过多。
  - 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉
  - 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口
  - 数据库分离：每个服务都使用自己的数据源
  - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护

## 2.5 es6语法

1.let:声明一个变量，不会越界 const：声明一个常量
2.字符串
	includes
	startsWith
	endsWith
	const ss = ``
3.解构表达式
	数组：let [x,y,z]=arr
	对象: let {name:a, age:b}=person
4.函数
	赋默认值：方法参数列表赋默认值 (a, b=1)=>{}
	箭头函数：()=>{}
	对象中定义函数：
		传统 eat：function(){}
		箭头 eat：()=>{}
		简写 eat(){}
	箭头函数结合结构表达式：({name})=>{}
5.map和reduce
	map(fun)：处理一个数组，遍历数组中的每一个元素用fun处理，把处理结果放入新的数组
	reduce(fun(a, b)[, 100])：没有初始值（1. a=10 b=20  2. a=30 b=30） 有初始值（1.a=100 b=10  2.a=110 b=20）
6.对象的扩展
	keys
	values
	entries：二维数组
	assign(dest, ...src)
7.数组扩展
	find findIndex includes

## 2.6 消息队列（MQ）

- 消息队列，即MQ，Message Queue。是一种应用程序对应用程序的通信方法
- MQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。
- JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。
- 常见MQ产品
  - ActiveMQ：基于JMS
  - RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好
  - RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会
  - Kafka：分布式消息系统，高吞吐量
- RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ

## 2.7 跨域问题

### 2.7.1 跨域：浏览器对于javascript的同源策略的限制 。

以下情况都属于跨域：

- 域名不同
- 域名相同，端口不同
- 二级域名不同
- http和https也属于跨域

### 2.7.2 为什么有跨域问题？

跨域不一定都会有跨域问题。

因为跨域问题是浏览器对于ajax请求的一种安全限制：**一个页面发起的ajax请求，只能是与当前页域名相同的路径**，这能有效的阻止跨站攻击。

因此：**跨域问题 是针对ajax的一种限制**。

### 2.7.3 解决跨域问题的方案

目前比较常用的跨域解决方案有3种：

- Jsonp

  最早的解决方案，利用script标签可以跨域的原理实现。

  限制：

  - 需要服务的支持
  - 只能发起GET请求

- nginx反向代理

  思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式

  缺点：需要在nginx进行额外配置，语义不清晰 

- CORS

  规范化的跨域请求解决方案，安全可靠。

  优势：

  - 在服务端进行控制是否允许跨域，可自定义规则
  - 支持各种请求方式

  缺点：

  - 会产生额外的请求

### 2.7.4 什么是cors

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。	

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

- 浏览器端：

  目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。

- 服务端：

  CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可

特殊请求会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

虽然原理比较复杂，但是前面说过：事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。

## 2.8 什么是无状态

微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即：

- 服务端不保存任何客户端请求者信息
- 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份

带来的好处是什么呢？

- 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务
- 服务端的集群和状态对客户端透明
- 服务端可以任意的迁移和伸缩
- 减小服务端存储压力

## 2.9 如何实现无状态

无状态登录的流程：

- 当客户端第一次请求服务时，服务端对用户进行信息认证（登录）
- 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证
- 以后每次请求，客户端都携带认证的token
- 服务的对token进行解密，判断是否有效。













  